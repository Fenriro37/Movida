
package Strutture_Dati;

public class AVL {
	private Nodo root;
	
	public AVL (Nodo R) {
		root = R;
		R = root.parent;
	};
	
	//funzioni da implementare
	
	public Nodo search (int k) {
		Nodo v = root;
		while(v != null) {
			if (k == v.key) {
				return v;
			}
			if (k < v.key) 
				v = v.left;	
			else 
				v = v.right;
		};
		return null;
	}
	
	public void Rotazione_SS (Nodo N) {
		Nodo t = N.left;
		N.left = t.right;
		t.right = N;
	}
	
	public void Rotazione_DD (Nodo N) {
		Nodo t = N.right;
		N.right = t.left;
		t.left = N;
	}
	//
	//
	//
	public void Rotazione_SD (Nodo V) {
		Nodo Z = V.left; //slide 31 alberi bilanciati di ricerca. Bisogna controllare se ci conviene aggiornare gli sbilanciamenti o se ci 
		Nodo W = Z.right;// basta richiamare la funzione sblianciamento dopo la rotazione.
		
		Z.right = W.left;
		V.left = W.right;
		W.left = Z;
		W.right = V;
	}
	
	public void Rotazione_DS (Nodo V) {
		Nodo Z = V.right;
		Nodo W = Z.left;
		
		Z.left = W.right;
		V.right = W.left;
		W.right = Z;
		W.left = V;
	}
	
	public int altezza(Nodo N) { //questa funzione snellisce la funzione sbilanciamento che altrimenti sarebbe dovuta
		if (N == null)			 //andare per casistiche su possibili figli nulli.
			return 0; 
		
	    return N.height; 
	    } 
	
	public int Sbilanciamento(Nodo N) { //<--- possiamo anche creare una funzione ricorsiva che essenzialmente conti i nodi dei due sottoalberi
		if (N == null) return 0;        //   per poi restituire l'altezza
		return altezza(N.left) - altezza(N.right);  
	}
	
	public Nodo max(Nodo v) {
		while (v != null &&
				v.right != null) {
				v = v.right;
				}
				return v;
				}

	
	public Nodo predecessore(Nodo v) {
		if (v == null) return null;
		
		if(v.left != null) return max(v.left);
		else   {	
	    Nodo tmp = v.parent;
		while (tmp!=null && v == tmp.left) {
			v=tmp;
			tmp =tmp.parent;
			}
		return tmp;
		}
	}
    	
	public void insert (Movie m, int key) {
		Nodo tmp = null; 
		while(root != null) {
			tmp = root;
			if (root.key>key) root=root.left; 
			else root = root.right;
		}
		Nodo N = new Nodo (key, m);
		N.parent = tmp;
		if (tmp == null) root = N;
		
		if (key<tmp.key) tmp.left=N;      //qui come nel while se il valore coincide con quello del padre viene messo a destra
		else tmp.right=N;
		
		//aggiorna_altezza() oppure N.parent.altezza+=1
	}
	
	public void delete (int key, Movie m) { //poichè ci possono essere più chiavi uguali bisogna passare anche il film
		//if (root.key == key && root.movie.getTitle().equals(m.getTitle())) root = null; // caso eliminazione radice
		
		Nodo tmp = null; 
		while(root != null) {
			tmp = root;
			if (root.key>key) root=root.left; 
			else root = root.right;
		
			}
		}
}

