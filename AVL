package Strutture_Dati;

public class AVL {
	private Nodo root;
	
	public AVL (Nodo R) {
		root = R;
		R = root.parent;
	};

	public int max (int a, int b) {
		if (a>=b)
			return a;
		else 
			return b;
	}
	
	public Nodo max(Nodo v) {
		while (v != null &&
				v.right != null) {
				v = v.right;
				}
				return v;
				}
	
	public Nodo predecessore(Nodo v) {
		if (v == null) return null;
		
		if(v.left != null) return max(v.left);
		else   {	
	    Nodo tmp = v.parent;
		while (tmp!=null && v == tmp.left) {
			v=tmp;
			tmp =tmp.parent;
			}
		return tmp;
		}
	}
	
	public void Rotazione_SS (Nodo V) {
		//aggiornamento puntatori
		Nodo U = V.left; 
		V.left = U.right; 
		U.right = V;
		//aggiornamento altezza
		V.height = max(V.left.height, V.right.height);
		U.height = max(U.left.height, U.right.height);
	}
	
	public void Rotazione_DD (Nodo V) {
		//aggiornamento puntatori
		Nodo U = V.right;
		V.right = U.left;
		U.left = V;
		//aggiornamento altezza
		V.height = max(V.left.height, V.right.height);
		U.height = max(U.left.height, U.right.height);
	}
	
	public void Rotazione_SD (Nodo V) {
		Nodo Z = V.left; //slide 31 alberi bilanciati di ricerca. Bisogna controllare se ci conviene aggiornare gli sbilanciamenti o se ci 
		Nodo W = Z.right;// basta richiamare la funzione sblianciamento dopo la rotazione.
		
		Z.right = W.left;
		V.left = W;
		W.left = Z;
		
		Z.height = max(Z.left.height, Z.right.height); 	//rotazione sd -> lo height in Z è negativo 
						//-> se Z scende il suo height aumenta
		
		Rotazione_SS(V);
	}
	
	public void Rotazione_DS (Nodo V) {
		Nodo Z = V.right;
		Nodo W = Z.left;
		
		Z.left = W.right;		
		V.right = W;
		W.right = Z;
		
		Z.height = max(Z.left.height, Z.right.height);
		Rotazione_DD(V);
	}
	
	public void AggiustaAltezze(Nodo N) {
		while (N!=N.parent) { //aggiornamento height cammino nodo radice
			N.parent.height = max(N.parent.left.height, N.parent.right.height); 
			N = N.parent;
		} 
	}
	public void AggiustaSbilanciamento(Nodo I) {
		I = I.parent;
		while (I!=I.parent) {
			if	(I.sbilanciamento() > 2 || I.sbilanciamento() < -2) {
				System.out.println("Sbilanciamento anomalo");
				break;
			}
			
			if (I.sbilanciamento() == 2) { //sbilanciamento a sinistra
				if (I.left.sbilanciamento() == 1)
					Rotazione_SS(I);
				else if(I.left.sbilanciamento() == -1)
					Rotazione_SD(I);
			}
				
			else if (I.sbilanciamento() == -2) { //sbilanciamento destra
				if (I.left.sbilanciamento() == 1)
					Rotazione_DS(I);
				else if(I.left.sbilanciamento() == -1)
					Rotazione_DD(I);
			}
			
			I = I.parent;
			
		}
	}
	
	public Nodo search (int k, Movie m) {
		Nodo v = root;
		while(v != null) {
			if (k == v.key && v.movie.getTitle().equals(m.getTitle())) {
				return v;
			}
			if (k < v.key) 
				v = v.left;	
			else 
				v = v.right;
		};
		return null;
	}
	
	public void insert (int key, Movie m) {
		Nodo tmp = null; 
		while(root != null) {
			tmp = root;
			if (root.key>key) root=root.left; 
			else root = root.right;
		}
		Nodo N = new Nodo (key, m);
		N.parent = tmp;
		
		if (tmp == null) root = N; //caso albero vuoto
		
		else if (key<tmp.key) tmp.left=N;      //qui come nel while se il valore coincide con quello del padre viene messo a destra
		else tmp.right=N;
		
		Nodo I = N;
		
		AggiustaAltezze(N);
		
		AggiustaSbilanciamento(I);
	}
	
	public void delete (int key, Movie m) { //poichè ci possono essere più chiavi uguali bisogna passare anche il film
	//if (root.key == key && root.movie.getTitle().equals(m.getTitle())
	//		&& root.left == null &&) root = null; // caso eliminazione radice
		Nodo I = search(key, m);
		if(I != null) {
			//caso foglia
			if(I.left == null && I.right == null) {
				Nodo P = I.parent;
			if(I!=P) {
				I = null;
				P.height = max(P.left.height, P.right.height);
				AggiustaAltezze(P);
			}
			
			I = null;
			//caso 1 figlio
			//caso 2 figli
		}
			
			
		
			
		}

}
